#!/usr/bin/env python3
"""
A2A-compliant host agent that can discover and communicate with merchants.
"""

import os
import httpx
from typing import Dict, Any, List, Optional
from dotenv import load_dotenv

from a2a.client import A2AClient, A2ACardResolver
from a2a.types import Message, MessageSendParams, MessageSendConfiguration, TextPart, SendMessageRequest, Task, TaskStatus

# X402 imports
from a2a_x402.core.utils import X402Utils
from a2a_x402.types import PaymentStatus, x402PaymentRequiredResponse

# Import signing service
from client.signing_service import SigningService

# Import merchant configuration to dynamically discover all merchants
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '..', 'server'))
from merchants import MERCHANTS

# X402 extension URI constant
X402_EXTENSION_URI = "https://github.com/google-a2a/a2a-x402/v0.1"

# Load environment
load_dotenv()


class A2AHostAgent:
    """A2A-compliant host agent with merchant discovery and X402 payment support."""
    
    def __init__(self, batch_mode=False):
        # Create HTTP client with X402 extension header
        headers = {"X-A2A-Extensions": X402_EXTENSION_URI}
        self.http_client = httpx.AsyncClient(timeout=30.0, headers=headers)
        self.merchants = {}
        self.merchant_clients = {}
        
        # X402 utilities
        self.x402_utils = X402Utils()
        
        # Initialize signing service with batch mode option
        self.batch_mode = batch_mode
        self.signing_service = SigningService(auto_sign=not batch_mode)
        
        # Track pending tasks when in batch mode
        self.pending_tasks = {}  # task_id -> (task, client, merchant_name)
        
        # Log wallet status
        wallet_info = self.signing_service.get_wallet_info()
        if wallet_info.get("configured"):
            mode = "batch collection" if batch_mode else "auto-sign"
            print(f"[Host] Signing service initialized in {mode} mode with wallet: {wallet_info.get('address')}")
        else:
            print("[Host] Warning: Signing service has no wallet configured")
        
        # Dynamically generate merchant URLs from configuration
        server_base = os.getenv("MERCHANT_SERVER_URL", "http://localhost:8001")
        self.merchant_urls = [
            f"{server_base}/agents/{merchant_id}"
            for merchant_id in MERCHANTS.keys()
        ]
    
    async def discover_merchants(self) -> Dict[str, Any]:
        """Discover available merchants using A2A protocol."""
        discovered = []
        
        for url in self.merchant_urls:
            try:
                # Use A2ACardResolver to get agent card
                resolver = A2ACardResolver(self.http_client, url)
                card = await resolver.get_agent_card()
                
                # Store merchant info
                self.merchants[card.name] = card
                self.merchant_clients[card.name] = A2AClient(self.http_client, card)
                
                # Extract skills for display
                skills = []
                if card.skills:
                    skills = [skill.name for skill in card.skills]
                
                discovered.append({
                    "name": card.name,
                    "description": card.description,
                    "url": url,
                    "skills": skills
                })
                
                
            except Exception as e:
                import traceback
                traceback.print_exc()
        
        return {
            "status": "success",
            "discovered_merchants": discovered,
            "total_found": len(discovered)
        }
    
    async def ask_merchant(self, merchant_name: str, question: str, auto_process_batch: bool = True) -> Dict[str, Any]:
        """Ask a merchant a question using A2A protocol with X402 payment support."""
        if merchant_name not in self.merchant_clients:
            return {
                "status": "error",
                "message": f"Merchant '{merchant_name}' not found. Try discovering merchants first."
            }
        
        try:
            client = self.merchant_clients[merchant_name]
            
            # Create A2A message following protocol
            import uuid
            
            msg_id = str(uuid.uuid4())
            send_request = SendMessageRequest(
                id=msg_id,
                params=MessageSendParams(
                    id=msg_id,
                    message=Message(
                        messageId=msg_id,
                        role="user",
                        parts=[TextPart(text=question)]
                    ),
                    configuration=MessageSendConfiguration(
                        acceptedOutputModes=["text/plain", "text"]
                    )
                )
            )
            
            # Send message to merchant
            response = await client.send_message(send_request)
            
            # Extract task from response
            task = None
            if hasattr(response, 'root') and hasattr(response.root, 'result'):
                task = response.root.result
            
            if task:
                # Check if payment is required
                payment_status = self.x402_utils.get_payment_status(task)
                
                if payment_status == PaymentStatus.PAYMENT_REQUIRED:
                    
                    # Handle payment if signing service is available
                    if self.signing_service.get_wallet_info().get("configured"):
                        paid_task = await self._handle_payment_required(task, client, merchant_name)
                        if paid_task:
                            task = paid_task
                    else:
                        return {
                            "status": "payment_required",
                            "message": "Payment is required but wallet is not configured",
                            "merchant": merchant_name
                        }
            
            # Extract the final message content to return to ADK
            if task:
                final_message = None
                
                # Add transaction explorer link if task completed with payment
                if task.status.state == "completed":
                    # Look for payment receipts in task history (where the actual payment completion is stored)
                    transaction_hash = None
                    network = 'sui-testnet'
                    
                    if hasattr(task, 'history') and task.history:
                        for message in task.history:
                            if (hasattr(message, 'metadata') and 
                                message.metadata and 
                                'x402.payment.receipts' in message.metadata):
                                
                                payment_receipts = message.metadata.get('x402.payment.receipts', [])
                                if payment_receipts and len(payment_receipts) > 0:
                                    receipt = payment_receipts[0]  # Get first receipt
                                    if isinstance(receipt, dict) and 'transaction' in receipt:
                                        transaction_hash = receipt['transaction']
                                        network = receipt.get('network', 'sui-testnet')
                                        break
                    
                    # Get the base message from task status
                    if (hasattr(task.status, 'message') and 
                        hasattr(task.status.message, 'parts') and 
                        task.status.message.parts):
                        try:
                            base_message = task.status.message.parts[0].root.text
                        except Exception as e:
                            # Try alternative access patterns
                            try:
                                first_part = task.status.message.parts[0]
                                if hasattr(first_part, 'text'):
                                    base_message = first_part.text
                                elif hasattr(first_part, 'content'):
                                    base_message = str(first_part.content)
                                else:
                                    base_message = str(first_part)
                            except:
                                base_message = str(task.status.message.parts[0])
                        
                        # If we found a transaction, enhance the message with transaction details
                        if transaction_hash:
                            # Create explorer link based on network
                            explorer_link = None
                            if network == 'sui-testnet':
                                explorer_link = f"https://testnet.suivision.xyz/txblock/{transaction_hash}"
                            elif network == 'sui-mainnet':
                                explorer_link = f"https://suivision.xyz/txblock/{transaction_hash}"
                            
                            if explorer_link:
                                final_message = f"{base_message}\n\n🔗 **Transaction Details**\nHash: `{transaction_hash}`\n📋 View on Explorer: {explorer_link}"
                            else:
                                final_message = base_message
                        else:
                            final_message = base_message
                
                # Return the enhanced message content directly
                if final_message:
                    return {
                        "status": "success",
                        "message": final_message,
                        "task_state": task.status.state,
                        "merchant": merchant_name
                    }
                else:
                    return {
                        "status": "success", 
                        "message": "Task completed but no message available",
                        "task_state": task.status.state if task.status else "unknown",
                        "merchant": merchant_name
                    }
            else:
                # Fallback to dictionary format if no task
                return {
                    "status": "error",
                    "message": "No task returned from merchant",
                    "merchant": merchant_name
                }
                
        except Exception as e:
            import traceback
            traceback.print_exc()
            return {
                "status": "error",
                "message": f"Failed to communicate with {merchant_name}: {str(e)}"
            }
    
    async def _handle_payment_required(self, task: Task, client: A2AClient, merchant_name: str) -> Optional[Task]:
        """Handle payment required response from merchant using signing service."""
        try:
            # Extract payment requirements from task
            payment_required = self.x402_utils.get_payment_requirements(task)
            if not payment_required:
                print(f"[Host] No payment requirements found in task")
                return None
            
            print(f"[Host] Processing payment for {merchant_name}...")
            
            # Delegate payment signing to signing service
            payment_context = {
                "merchant": merchant_name,
                "task_id": task.id
            }
            payment_payload = await self.signing_service.process_payment_required(
                payment_required,
                payment_context
            )
            
            if not payment_payload:
                if self.batch_mode:
                    # In batch mode, payment is collected but not signed yet
                    print(f"[Host] Payment requirement collected for batch processing")
                    # Store task for later submission
                    self.pending_tasks[task.id] = (task, client, merchant_name)
                    return task  # Return task to show pending status in UI
                else:
                    print(f"[Host] Signing service could not process payment")
                    return None
            
            # Use the proper correlation method from a2a_x402
            from a2a_x402.core.utils import create_payment_submission_message
            
            # Create properly correlated payment submission message
            payment_message = create_payment_submission_message(
                task_id=task.id,  # CRITICAL: Original task ID for correlation
                payment_payload=payment_payload,
                text="Payment authorization provided"
            )
            # Fix the context_id manually since create_payment_submission_message doesn't set it
            payment_message.context_id = task.context_id
            
            # Submit payment with correlated message
            import uuid
            msg_id = str(uuid.uuid4())
            send_request = SendMessageRequest(
                id=msg_id,
                params=MessageSendParams(
                    id=msg_id,  # This is the message ID, not task ID
                    message=payment_message,
                    configuration=MessageSendConfiguration(
                        acceptedOutputModes=["text/plain", "text"]
                    )
                )
            )
            
            # Send payment and get updated task
            payment_response = await client.send_message(send_request)
            
            # Extract and return updated task
            if hasattr(payment_response, 'root') and hasattr(payment_response.root, 'result'):
                return payment_response.root.result
            
            return None
            
        except Exception as e:
            import traceback
            traceback.print_exc()
            return None
    
    async def process_batch_payments(self) -> Dict[str, Any]:
        """
        Process all collected payments in batch mode.
        
        1. Review pending payments
        2. Sign all payments
        3. Submit each signed payment to its merchant
        
        Returns:
            Summary of processed payments
        """
        if not self.batch_mode:
            return {"error": "Not in batch mode"}
        
        # Review what we're about to sign
        review = await self.signing_service.review_pending_payments()
        print(f"\n[Host] Ready to process {review['pending_count']} payments")
        print(f"[Host] Total amount: ${review['total_amount']:.3f}")
        
        # Sign all pending payments
        signed_payments = await self.signing_service.sign_pending_payments()
        
        if not signed_payments:
            return {"error": "No payments were signed"}
        
        # Now submit each signed payment to its merchant
        results = []
        for task_id, payment_payload in signed_payments.items():
            if task_id not in self.pending_tasks:
                print(f"[Host] Warning: No pending task found for {task_id}")
                continue
            
            task, client, merchant_name = self.pending_tasks[task_id]
            
            print(f"[Host] Submitting payment for task {task_id} to {merchant_name}...")
            
            try:
                # Create payment submission message
                from a2a_x402.core.utils import create_payment_submission_message
                
                payment_message = create_payment_submission_message(
                    task_id=task.id,  # Original task ID for correlation
                    payment_payload=payment_payload,
                    text="Payment authorization provided"
                )
                # Fix the context_id manually
                payment_message.context_id = task.context_id
                
                # Submit payment
                import uuid
                msg_id = str(uuid.uuid4())
                send_request = SendMessageRequest(
                    id=msg_id,
                    params=MessageSendParams(
                        id=msg_id,
                        message=payment_message,
                        configuration=MessageSendConfiguration(
                            acceptedOutputModes=["text/plain", "text"]
                        )
                    )
                )
                
                # Send payment and get updated task
                payment_response = await client.send_message(send_request)
                
                # Extract result with simplified error handling
                if hasattr(payment_response, 'root') and hasattr(payment_response.root, 'result'):
                    final_task = payment_response.root.result
                    task_state = final_task.status.state if hasattr(final_task, 'status') and final_task.status else "unknown"
                    
                    # Simple message extraction
                    message_content = f"Payment submitted - Status: {task_state}"
                    transaction_hash = None
                    
                    # Try to get transaction hash if available
                    try:
                        if hasattr(final_task, 'history') and final_task.history:
                            for message in final_task.history:
                                if (hasattr(message, 'metadata') and 
                                    message.metadata and 
                                    'x402.payment.receipts' in message.metadata):
                                    
                                    payment_receipts = message.metadata.get('x402.payment.receipts', [])
                                    if payment_receipts and len(payment_receipts) > 0:
                                        receipt = payment_receipts[0]
                                        if isinstance(receipt, dict) and 'transaction' in receipt:
                                            transaction_hash = receipt['transaction']
                                            explorer_link = f"https://testnet.suivision.xyz/txblock/{transaction_hash}"
                                            message_content = f"✅ Payment completed!\nStatus: {task_state}\n🔗 Transaction: {explorer_link}"
                                            break
                    except Exception as e:
                        print(f"[Host] Note: Could not extract transaction details: {e}")
                    
                    results.append({
                        "task_id": task_id,
                        "merchant": merchant_name,
                        "status": "success" if task_state == "completed" else "partial",
                        "state": task_state,
                        "message": message_content,
                        "transaction_hash": transaction_hash
                    })
                else:
                    results.append({
                        "task_id": task_id,
                        "merchant": merchant_name,
                        "status": "error",
                        "error": "No task returned"
                    })
                    
            except Exception as e:
                import traceback
                traceback.print_exc()
                results.append({
                    "task_id": task_id,
                    "merchant": merchant_name,
                    "status": "error",
                    "error": str(e)
                })
        
        # Clear pending tasks
        self.pending_tasks.clear()
        
        # Create user-friendly summary
        successful_results = [r for r in results if r["status"] == "success"]
        failed_results = [r for r in results if r["status"] == "error"]
        
        summary_lines = []
        summary_lines.append(f"🔄 **Batch Payment Complete**")
        summary_lines.append(f"✅ Processed: {len(results)} payments")
        summary_lines.append(f"💰 Total requested: ${review['total_amount']:.3f}")
        
        if successful_results:
            summary_lines.append(f"\n**✅ Successful ({len(successful_results)}):**")
            for result in successful_results:
                message = result.get('message', 'Task completed')
                if result.get("transaction_hash"):
                    summary_lines.append(f"• {result['merchant']}: {message}")
                else:
                    summary_lines.append(f"• {result['merchant']}: {message}")
        
        if failed_results:
            summary_lines.append(f"\n**❌ Failed ({len(failed_results)}):**")
            for result in failed_results:
                summary_lines.append(f"• {result['merchant']}: {result.get('error', 'Unknown error')}")
        
        summary_lines.append(f"\n💡 *Single transaction used for all payments (batch mode)*")
        
        return {
            "status": "success",
            "message": "\n".join(summary_lines),
            "processed_count": len(results),
            "successful_count": len(successful_results),
            "failed_count": len(failed_results),
            "total_amount": review['total_amount'],
            "results": results
        }
    
    def get_merchant_list(self) -> List[str]:
        """Get list of discovered merchants."""
        return list(self.merchants.keys())


# Create global instance for ADK integration
# Batch mode can be controlled via BATCH_MODE environment variable
import os
batch_mode = os.getenv("BATCH_MODE", "false").lower() == "true"
print(f"[Host] Initializing with batch_mode={batch_mode}")
host_agent = A2AHostAgent(batch_mode=batch_mode)